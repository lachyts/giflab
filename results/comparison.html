<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GifLab Comparison Tool (Fixed Discovery)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .cors-warning {
            background: #ff6b6b;
            color: white;
            padding: 20px;
            margin: 20px auto;
            max-width: 1200px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }

        .cors-warning h3 {
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .cors-warning code {
            background: rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 5px;
            display: block;
            margin: 10px 0;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .controls {
            background: white;
            padding: 30px;
            margin: 30px auto;
            max-width: 1200px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            background: white;
            transition: border-color 0.3s;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
        }

        select:disabled {
            background-color: #f8f9fa;
            color: #6c757d;
        }

        .pipeline-filters {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 2px solid #e1e5e9;
        }

        .pipeline-filters h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.3em;
        }

        .pipeline-checkboxes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .pipeline-checkbox {
            display: flex;
            align-items: center;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            transition: all 0.3s;
            cursor: pointer;
            background: white;
        }

        .pipeline-checkbox:hover {
            border-color: #667eea;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.1);
        }

        .pipeline-checkbox.selected {
            border-color: #667eea;
            background-color: #f8f9ff;
        }

        .pipeline-checkbox input[type="checkbox"] {
            margin-right: 12px;
            transform: scale(1.2);
            accent-color: #667eea;
        }

        .pipeline-info {
            flex: 1;
        }

        .pipeline-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .pipeline-stats {
            font-size: 0.9em;
            color: #666;
        }

        .efficiency-bar {
            width: 100px;
            height: 6px;
            background-color: #e1e5e9;
            border-radius: 3px;
            margin-left: 15px;
            overflow: hidden;
        }

        .efficiency-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s;
        }

        .efficiency-excellent { background-color: #4CAF50; }
        .efficiency-good { background-color: #8BC34A; }
        .efficiency-fair { background-color: #FFC107; }
        .efficiency-poor { background-color: #FF5722; }

        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            max-width: 1200px;
            margin: 30px auto;
            padding: 0 30px;
        }

        .gif-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .gif-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.15);
        }

        .gif-container {
            position: relative;
            background: #f8f9fa;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .gif-container img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .gif-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            color: white;
            padding: 20px;
        }

        .gif-title {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-link {
            background: rgba(255,255,255,0.3);
            color: white;
            text-decoration: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8em;
            font-weight: 500;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: 4px;
        }

        .copy-path-button {
            background: rgba(255,255,255,0.3);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8em;
            font-weight: 500;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: 4px;
        }

        .copy-path-button:hover {
            background: rgba(255,255,255,0.5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .copy-path-button.copied {
            background: rgba(76, 175, 80, 0.8);
            border-color: rgba(76, 175, 80, 0.6);
        }

        .file-link:hover {
            background: rgba(255,255,255,0.5);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .file-link::before {
            content: "üîó";
            font-size: 0.9em;
        }

        .metadata {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            font-size: 0.9em;
        }

        .metadata span {
            background: rgba(255,255,255,0.2);
            padding: 4px 8px;
            border-radius: 4px;
            backdrop-filter: blur(10px);
        }

        .metrics-panel {
            background: white;
            margin: 30px auto;
            max-width: 1200px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .metrics-header {
            background: #667eea;
            color: white;
            padding: 20px 30px;
            font-size: 1.3em;
            font-weight: 600;
        }

        .metrics-table {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 2000px; /* Increased for new timing columns */
        }

        th, td {
            padding: 8px 12px; /* Reduced padding for more columns */
            text-align: left;
            border-bottom: 1px solid #e1e5e9;
            white-space: nowrap;
        }

        th {
            background: #f8f9fa;
            font-weight: 600;
            color: #555;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        /* Sticky first column for pipeline names */
        th:first-child, td:first-child {
            position: sticky;
            left: 0;
            background: #fff;
            z-index: 5;
            border-right: 2px solid #e1e5e9;
        }

        th:first-child {
            background: #f8f9fa;
            z-index: 15;
        }

        tr:hover {
            background-color: #f8f9ff;
        }

        /* Color coding for quality metrics */
        .metric-excellent { background-color: #d4edda; color: #155724; }
        .metric-good { background-color: #d1ecf1; color: #0c5460; }
        .metric-fair { background-color: #fff3cd; color: #856404; }
        .metric-poor { background-color: #f8d7da; color: #721c24; }

        /* FPS validation color coding */
        .fps-excellent { background-color: #d4edda; color: #155724; } /* ¬±5% */
        .fps-good { background-color: #d1ecf1; color: #0c5460; } /* ¬±10% */
        .fps-fair { background-color: #fff3cd; color: #856404; } /* ¬±20% */
        .fps-poor { background-color: #f8d7da; color: #721c24; } /* >20% */
        
        .fps-warning::after {
            content: " ‚ö†Ô∏è";
            font-size: 0.8em;
        }

        /* Data quality indicator styling */
        .data-error {
            border-left: 3px solid #dc3545;
            background-color: #f8d7da !important;
        }
        
        .data-warning {
            border-left: 3px solid #ffc107;
            background-color: #fff3cd !important;
        }
        
        .data-estimated {
            border-left: 3px solid #17a2b8;
            background-color: #d1ecf1 !important;
        }
        
        .data-incomplete {
            border-left: 3px solid #6c757d;
            background-color: #e2e3e5 !important;
        }
        
        .data-good {
            border-left: 3px solid #28a745;
        }
        
        /* Data quality indicators in table headers */
        .data-quality-legend {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .data-quality-legend .legend-item {
            display: inline-block;
            margin-right: 15px;
        }
        
        .data-quality-legend .legend-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border-radius: 2px;
        }

        /* Tooltip styling */
        .metric-cell {
            position: relative;
            cursor: help;
        }

        .metric-cell:hover::after {
            content: attr(title);
            position: absolute;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: normal;
            width: 200px;
            z-index: 1000;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 5px;
        }

        .metric-cell:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #333;
        }

        /* Details button styling */
        .details-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .details-btn:hover {
            background: #5a67d8;
        }

        .details-btn.expanded {
            background: #e53e3e;
        }

        /* Frame breakdown row styling */
        .frame-breakdown-row {
            background: #f8f9ff;
            border-left: 4px solid #667eea;
        }

        .frame-breakdown-content {
            padding: 20px;
            font-size: 14px;
        }

        .frame-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        .frame-item {
            background: white;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #e1e5e9;
        }

        /* FPS warning card styling */
        .fps-warning-card {
            animation: pulse-warning 2s infinite;
        }

        @keyframes pulse-warning {
            0% { box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
            50% { box-shadow: 0 4px 20px rgba(255, 107, 107, 0.3); }
            100% { box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
        }

        .hidden {
            display: none;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 20px;
            margin: 20px;
            border-radius: 8px;
            border-left: 4px solid #c62828;
        }

        @media (max-width: 768px) {
            .comparison-grid {
                grid-template-columns: 1fr;
                padding: 0 15px;
            }
            
            .controls {
                margin: 15px;
                padding: 20px;
            }
            
            .pipeline-checkboxes {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéØ GifLab Comparison Tool</h1>
        <p>Visual comparison of GIF compression algorithms and pipelines</p>
    </div>

    <div class="cors-warning" id="corsWarning">
        <h3>‚ö†Ô∏è Cannot Load Experiments</h3>
        <p>If you're seeing this message, the page can't load experiment data due to CORS restrictions.</p>
        <p><strong>To fix this, run a local HTTP server:</strong></p>
        <code>cd /Users/lachlants/repos/animately/giflab/results<br>python -m http.server 3000</code>
        <p>Then open: <strong>http://localhost:3000/comparison.html</strong></p>
        <p><em>Alternative: From project root, use <code>poetry run python -m http.server 8001</code> then open <strong>http://localhost:8001/results/comparison.html</strong></em></p>
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="experimentSelect">Select Experiment:</label>
            <select id="experimentSelect">
                <option value="">Loading experiments...</option>
            </select>
        </div>

        <div class="control-group">
            <label for="gifSelect">Select GIF:</label>
            <select id="gifSelect" disabled>
                <option value="">Select an experiment first</option>
            </select>
        </div>

        <div class="pipeline-filters hidden" id="pipelineFilters">
            <h3>Compare Pipelines:</h3>
            <div class="pipeline-checkboxes" id="pipelineCheckboxes">
                <!-- Dynamically populated -->
            </div>
        </div>
    </div>

    <div class="comparison-grid" id="comparisonGrid">
        <!-- GIF comparison cards will be added here -->
    </div>

    <div class="metrics-panel hidden" id="metricsPanel">
        <div class="metrics-header">Detailed Comparison Metrics</div>
        <div class="data-quality-legend">
            <strong>Data Quality Indicators:</strong>
            <span class="legend-item">
                <span class="legend-color" style="background-color: #28a745;"></span>Complete Data
            </span>
            <span class="legend-item">
                <span class="legend-color" style="background-color: #17a2b8;"></span>Estimated Values
            </span>
            <span class="legend-item">
                <span class="legend-color" style="background-color: #ffc107;"></span>Data Warnings
            </span>
            <span class="legend-item">
                <span class="legend-color" style="background-color: #6c757d;"></span>Incomplete Data
            </span>
            <span class="legend-item">
                <span class="legend-color" style="background-color: #dc3545;"></span>Data Errors
            </span>
        </div>
        <div class="metrics-table">
            <table id="metricsTable">
                <thead>
                    <tr>
                        <th>Pipeline</th>
                        <th>File Size</th>
                        <th>Frames</th>
                        <th>Compression</th>
                        <th>Overall Quality</th>
                        <th>SSIM</th>
                        <th>MS-SSIM</th>
                        <th>PSNR</th>
                        <th>MSE</th>
                        <th>RMSE</th>
                        <th>FSIM</th>
                        <th>GMSD</th>
                        <th>CHIST</th>
                        <th>Edge Sim</th>
                        <th>Texture Sim</th>
                        <th>Sharpness Sim</th>
                        <th>Temporal Pre</th>
                        <th>Temporal Post</th>
                        <th>Temporal Delta</th>
                        <th>Disposal Pre</th>
                        <th>Disposal Post</th>
                        <th>Disposal Delta</th>
                        <th>Original FPS</th>
                        <th>Compressed FPS</th>
                        <th>FPS Delta</th>
                        <th>Duration (sec)</th>
                        <th>Timing Consistency</th>
                        <th>Efficiency</th>
                        <th>Render Time</th>
                        <th>Details</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Dynamically populated -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        class GifLabComparison {
            constructor() {
                this.experiments = [];
                this.currentExperiment = null;
                this.currentGif = null;
                this.selectedPipelines = new Set();
                
                this.initializeElements();
                this.loadCatalog();
            }

            initializeElements() {
                this.experimentSelect = document.getElementById('experimentSelect');
                this.gifSelect = document.getElementById('gifSelect');
                this.pipelineFilters = document.getElementById('pipelineFilters');
                this.pipelineCheckboxes = document.getElementById('pipelineCheckboxes');
                this.comparisonGrid = document.getElementById('comparisonGrid');
                this.metricsPanel = document.getElementById('metricsPanel');
                this.metricsTable = document.getElementById('metricsTable');
                
                this.experimentSelect.addEventListener('change', (e) => {
                    this.selectExperiment(e.target.value);
                });
                
                this.gifSelect.addEventListener('change', (e) => {
                    this.selectGif(e.target.value);
                });
            }

            async loadCatalog() {
                // Check if we're opening from file:// protocol - show server instructions immediately
                if (window.location.protocol === 'file:') {
                    document.getElementById('corsWarning').style.display = 'block';
                    this.showError('No experiments found. Run some experiments to get started!');
                    return;
                }
                
                try {
                    console.log('üîç Scanning filesystem for experiments...');
                    
                    // Discover experiments directly from filesystem
                    this.experiments = await this.discoverExperimentsFromFilesystem();
                    
                    this.populateExperimentSelect();
                    
                    if (this.experiments.length === 0) {
                        this.showError('No experiments found. Run some experiments to get started!');
                    } else {
                        console.log(`‚úÖ Found ${this.experiments.length} experiments`);
                    }
                    
                } catch (error) {
                    console.error('Failed to discover experiments:', error);
                    
                    // Show CORS warning if it's likely a CORS issue
                    if (error.message.includes('CORS') || error.message.includes('network')) {
                        document.getElementById('corsWarning').style.display = 'block';
                    }
                    
                    this.showError('Failed to scan experiments directory. Make sure you have run at least one experiment.');
                }
            }

            populateExperimentSelect() {
                this.experimentSelect.innerHTML = '<option value="">Select Experiment...</option>';
                
                // Sort experiments by date (newest first)
                const sortedExperiments = [...this.experiments].sort((a, b) => 
                    new Date(b.date) - new Date(a.date)
                );
                
                sortedExperiments.forEach(exp => {
                    const option = document.createElement('option');
                    option.value = exp.id;
                    option.textContent = `${exp.name} (${this.formatDate(exp.date)})`;
                    this.experimentSelect.appendChild(option);
                });
            }

            async selectExperiment(experimentId) {
                if (!experimentId) {
                    this.gifSelect.disabled = true;
                    this.gifSelect.innerHTML = '<option value="">Select an experiment first</option>';
                    this.pipelineFilters.classList.add('hidden');
                    this.clearComparison();
                    return;
                }

                try {
                    // Load experiment from new visual_outputs structure
                    await this.loadExperimentFromVisualOutputs(experimentId);
                    this.populateGifSelect();
                } catch (error) {
                    console.error('Failed to load experiment:', error);
                    this.showError(`Failed to load experiment data for ${experimentId}`);
                }
            }

            async loadExperimentFromVisualOutputs(experimentId) {
                // Try to get list of GIFs from visual_outputs directory
                const visualOutputsPath = `runs/${experimentId}/visual_outputs`;
                
                // First get experiment metadata
                const metadataResponse = await fetch(`runs/${experimentId}/run_metadata.json`);
                const metadata = await metadataResponse.json();
                
                this.currentExperiment = {
                    experiment: { id: experimentId },
                    metadata: metadata,
                    gifs: []
                };

                // Load available GIFs by looking for directories with metrics.json
                const availableGifs = await this.discoverGifsInVisualOutputs(visualOutputsPath);
                
                for (const gifName of availableGifs) {
                    try {
                        const metricsResponse = await fetch(`${visualOutputsPath}/${gifName}/metrics.json`);
                        const metrics = await metricsResponse.json();
                        
                        const gifData = this.convertMetricsToGifData(gifName, metrics, visualOutputsPath);
                        this.currentExperiment.gifs.push(gifData);
                    } catch (error) {
                        console.warn(`Failed to load metrics for ${gifName}:`, error);
                    }
                }
            }

            async discoverGifsInVisualOutputs(basePath) {
                // Try to discover available GIFs by testing known GIF names
                const knownGifNames = [
                    'animation_heavy', 'complex_gradient', 'data_visualization', 'extended_animation',
                    'few_colors', 'geometric_patterns', 'gradient_large', 'gradient_medium', 
                    'gradient_small', 'gradient_xlarge', 'high_contrast', 'high_frequency_detail',
                    'long_animation', 'many_colors', 'minimal_frames', 'mixed_content',
                    'noise_large', 'noise_small', 'photographic_noise', 'single_pixel_anim',
                    'smooth_gradient', 'solid_blocks', 'static_minimal_change', 'texture_complex', 
                    'transitions'
                ];
                
                const availableGifs = [];
                for (const gifName of knownGifNames) {
                    try {
                        const response = await fetch(`${basePath}/${gifName}/metrics.json`);
                        if (response.ok) {
                            availableGifs.push(gifName);
                        }
                    } catch (error) {
                        // GIF not available, skip
                    }
                }
                return availableGifs;
            }

            // Enhanced data integration helper functions
            
            parseOriginalInfo(originalInfo) {
                const parsed = {
                    filename: originalInfo.filename || 'unknown.gif',
                    size_kb: originalInfo.size_kb || originalInfo.orig_kilobytes || 0,
                    frame_count: originalInfo.frame_count || originalInfo.orig_frames || 1,
                    content_type: originalInfo.content_type || 'unknown',
                    
                    // Extract additional fields if available
                    width: originalInfo.width || originalInfo.orig_width || null,
                    height: originalInfo.height || originalInfo.orig_height || null,
                    colors: originalInfo.colors || originalInfo.orig_n_colors || null,
                    entropy: originalInfo.entropy || null,
                    
                    // Calculate/estimate FPS and timing using multiple strategies
                    fps: this.calculateOriginalFPS(originalInfo),
                    duration: this.estimateDuration(originalInfo)
                };
                
                return parsed;
            }
            
            calculateOriginalFPS(data) {
                // Priority 1: Direct FPS data
                if (data.orig_fps && data.orig_fps > 0) {
                    data._fps_source = 'direct';
                    return data.orig_fps;
                }
                if (data.fps && data.fps > 0) {
                    data._fps_source = 'direct';
                    return data.fps;
                }
                
                // Priority 2: Calculate from timing data
                if (data.frame_delays && data.frame_delays.length > 0) {
                    const avgDelay = data.frame_delays.reduce((a, b) => a + b) / data.frame_delays.length;
                    if (avgDelay > 0) {
                        data._fps_source = 'calculated';
                        return 1000 / avgDelay;
                    }
                }
                
                // Priority 3: Estimate from content type and frame count
                const contentTypeDefaults = {
                    'animation_heavy': 15.0, // High motion content typically faster
                    'smooth_gradient': 10.0, // Smooth animations typically slower
                    'static_minimal_change': 5.0, // Static content very slow
                    'high_frequency_detail': 12.0, // Detail changes need moderate speed
                    'data_visualization': 8.0, // Data viz typically slower
                    'geometric_patterns': 10.0, // Geometric typically moderate
                    'photographic_noise': 12.0, // Photo content moderate
                    'complex_gradient': 8.0,
                    'many_colors': 12.0,
                    'few_colors': 10.0,
                    'high_contrast': 11.0,
                    'noise_large': 13.0,
                    'noise_small': 14.0,
                    'transitions': 9.0
                };
                
                const defaultFPS = contentTypeDefaults[data.content_type] || 10.0;
                
                // Mark as estimated
                data._fps_source = 'estimated';
                data._fps_estimated = true;
                
                // Adjust based on frame count (more frames = potentially slower for same duration)
                const frameCount = data.frame_count || data.orig_frames || 8;
                if (frameCount <= 3) return defaultFPS * 0.7; // Short animations slower
                if (frameCount >= 20) return defaultFPS * 1.2; // Long animations faster
                
                return defaultFPS;
            }
            
            estimateDuration(data) {
                const frameCount = data.frame_count || data.orig_frames || 8;
                const fps = this.calculateOriginalFPS(data);
                
                if (fps && frameCount) {
                    return frameCount / fps;
                }
                
                // Fallback duration estimates based on content type
                const contentTypeDurations = {
                    'animation_heavy': frameCount * 0.067, // ~15 FPS
                    'smooth_gradient': frameCount * 0.1, // ~10 FPS
                    'static_minimal_change': frameCount * 0.2, // ~5 FPS
                    'data_visualization': frameCount * 0.125 // ~8 FPS
                };
                
                return contentTypeDurations[data.content_type] || frameCount * 0.1;
            }
            
            extractAllAvailableMetrics(compressionData) {
                const metrics = {};
                
                // Core quality metrics with comprehensive extraction
                const qualityMetrics = [
                    'ssim', 'ms_ssim', 'psnr', 'mse', 'rmse', 
                    'fsim', 'gmsd', 'chist', 'edge_similarity',
                    'texture_similarity', 'sharpness_similarity'
                ];
                
                qualityMetrics.forEach(metric => {
                    metrics[metric] = {
                        mean: compressionData[`${metric}_mean`] || compressionData[metric] || null,
                        std: compressionData[`${metric}_std`] || null,
                        min: compressionData[`${metric}_min`] || null,
                        max: compressionData[`${metric}_max`] || null,
                        raw: compressionData[`${metric}_raw`] || []
                    };
                });
                
                // Temporal and artifact metrics
                metrics.temporal = {
                    consistency: compressionData.temporal_consistency || null,
                    pre: compressionData.temporal_consistency_pre || null,
                    post: compressionData.temporal_consistency_post || null,
                    delta: compressionData.temporal_consistency_delta || null
                };
                
                metrics.disposal = {
                    pre: compressionData.disposal_artifacts_pre ?? 1.0,
                    post: compressionData.disposal_artifacts_post ?? 1.0,
                    delta: compressionData.disposal_artifacts_delta ?? 0.0
                };
                
                // Extract timing and FPS data
                metrics.timing = {
                    fps: compressionData.compressed_fps || compressionData.fps || null,
                    duration: compressionData.compressed_duration || compressionData.duration || null,
                    frame_delays: compressionData.frame_delays || [],
                    consistency: compressionData.timing_consistency || null
                };
                
                return metrics;
            }
            
            validateMetricsData(data, source = 'unknown') {
                const validation = {
                    isValid: true,
                    warnings: [],
                    errors: [],
                    completeness: 0,
                    estimatedFields: []
                };
                
                // Check critical fields
                const criticalFields = ['file_size_kb', 'compression_ratio', 'enhanced_composite_quality'];
                const availableFields = criticalFields.filter(field => 
                    data[field] != null && data[field] !== 'N/A'
                );
                
                validation.completeness = availableFields.length / criticalFields.length;
                
                if (validation.completeness < 0.5) {
                    validation.errors.push(`Insufficient critical data from ${source}`);
                    validation.isValid = false;
                }
                
                // Validate data ranges for quality metrics
                if (data.enhanced_composite_quality != null) {
                    const quality = parseFloat(data.enhanced_composite_quality);
                    if (quality < 0 || quality > 1) {
                        validation.warnings.push(`Quality score out of range: ${quality.toFixed(3)}`);
                    }
                }
                
                // Check for estimated vs measured data
                if (data._fps_estimated || data._fps_source === 'estimated') {
                    validation.estimatedFields.push('FPS (estimated from content type)');
                }
                
                if (data._duration_estimated) {
                    validation.estimatedFields.push('Duration (estimated)');
                }
                
                return validation;
            }
            
            calculateCompressedFPS(compressionData, originalInfo) {
                // Try compression-specific FPS data first
                if (compressionData.compressed_fps && compressionData.compressed_fps > 0) {
                    return compressionData.compressed_fps;
                }
                
                // Calculate from compressed frame delays if available
                if (compressionData.frame_delays && compressionData.frame_delays.length > 0) {
                    const avgDelay = compressionData.frame_delays.reduce((a, b) => a + b) / compressionData.frame_delays.length;
                    return avgDelay > 0 ? 1000 / avgDelay : null;
                }
                
                // Estimate based on frame reduction ratio and original FPS
                const originalFPS = originalInfo.fps;
                const frameReductionRatio = compressionData.applied_frame_ratio || 1.0;
                
                if (originalFPS && frameReductionRatio !== 1.0) {
                    // For frame reduction, FPS typically stays the same but duration changes
                    return originalFPS;
                }
                
                // Fallback to original FPS
                return originalFPS;
            }
            
            calculateCompressedDuration(compressionData, originalInfo) {
                // Try direct duration data
                if (compressionData.compressed_duration && compressionData.compressed_duration > 0) {
                    return compressionData.compressed_duration;
                }
                
                // Calculate from frame delays
                if (compressionData.frame_delays && compressionData.frame_delays.length > 0) {
                    const totalDelayMs = compressionData.frame_delays.reduce((a, b) => a + b);
                    return totalDelayMs / 1000;
                }
                
                // Calculate from compressed frame count and FPS
                const compressedFrameCount = compressionData.compressed_frame_count || compressionData.frame_count;
                const compressedFPS = this.calculateCompressedFPS(compressionData, originalInfo);
                
                if (compressedFrameCount && compressedFPS) {
                    return compressedFrameCount / compressedFPS;
                }
                
                // Fallback: adjust original duration by frame reduction ratio
                const originalDuration = originalInfo.duration;
                const frameReductionRatio = compressionData.applied_frame_ratio || 1.0;
                
                if (originalDuration && frameReductionRatio !== 1.0) {
                    return originalDuration * frameReductionRatio;
                }
                
                return originalDuration;
            }

            convertMetricsToGifData(gifName, metrics, basePath) {
                const pipelines = [];
                
                // Parse original info with enhanced data extraction
                const originalInfo = this.parseOriginalInfo(metrics.original_info || {});
                
                // Convert each compression to pipeline format with comprehensive data extraction
                Object.entries(metrics.compressions).forEach(([compressionName, data]) => {
                    // Extract all available metrics using the comprehensive extraction function
                    const allMetrics = this.extractAllAvailableMetrics(data);
                    
                    // Validate the data and get validation info
                    const validation = this.validateMetricsData(data, `compression-${compressionName}`);
                    
                    // Build pipeline object with comprehensive data
                    const pipeline = {
                        id: compressionName,
                        display_name: this.generateDisplayName(data),
                        file_size_kb: data.file_size_kb || 0,
                        compression_ratio: data.compression_ratio || 1,
                        enhanced_composite_quality: data.enhanced_composite_quality || data.composite_quality || 0,
                        
                        // Individual quality metrics (use mean values with fallbacks)
                        ssim: allMetrics.ssim.mean || 'N/A',
                        ms_ssim: allMetrics.ms_ssim.mean || 'N/A',
                        psnr: allMetrics.psnr.mean || 'N/A',
                        mse: allMetrics.mse.mean || 'N/A',
                        rmse: allMetrics.rmse.mean || 'N/A',
                        fsim: allMetrics.fsim.mean || 'N/A',
                        gmsd: allMetrics.gmsd.mean || 'N/A',
                        chist: allMetrics.chist.mean || 'N/A',
                        edge_similarity: allMetrics.edge_similarity.mean || 'N/A',
                        texture_similarity: allMetrics.texture_similarity.mean || 'N/A',
                        sharpness_similarity: allMetrics.sharpness_similarity.mean || 'N/A',
                        
                        // Temporal consistency metrics
                        temporal_consistency_pre: allMetrics.temporal.pre || 'N/A',
                        temporal_consistency_post: allMetrics.temporal.post || 'N/A',
                        temporal_consistency_delta: allMetrics.temporal.delta || 'N/A',
                        
                        // Disposal artifacts
                        disposal_artifacts_pre: allMetrics.disposal.pre,
                        disposal_artifacts_post: allMetrics.disposal.post,
                        disposal_artifacts_delta: allMetrics.disposal.delta,
                        
                        // Enhanced timing and FPS metrics with intelligent fallbacks
                        original_fps: originalInfo.fps || 'N/A',
                        compressed_fps: allMetrics.timing.fps || this.calculateCompressedFPS(data, originalInfo) || 'N/A',
                        original_duration: originalInfo.duration || 'N/A',
                        compressed_duration: allMetrics.timing.duration || this.calculateCompressedDuration(data, originalInfo) || 'N/A',
                        frame_delays: allMetrics.timing.frame_delays,
                        timing_consistency: allMetrics.timing.consistency || this.calculateTimingConsistency(allMetrics.timing.frame_delays),
                        
                        // Enhanced raw metric arrays for frame-by-frame breakdown
                        raw_metrics: {
                            ssim_raw: allMetrics.ssim.raw,
                            ms_ssim_raw: allMetrics.ms_ssim.raw,
                            psnr_raw: allMetrics.psnr.raw,
                            mse_raw: allMetrics.mse.raw,
                            fsim_raw: allMetrics.fsim.raw,
                            edge_raw: allMetrics.edge_similarity.raw,
                            texture_raw: allMetrics.texture_similarity.raw,
                            sharpness_raw: allMetrics.sharpness_similarity.raw,
                            frame_delays: allMetrics.timing.frame_delays
                        },
                        
                        // Additional metadata and computed fields
                        efficiency: this.calculateEfficiency(data),
                        render_time_ms: data.render_time_ms || 0,
                        frame_count: data.compressed_frame_count || data.frame_count || originalInfo.frame_count || 'N/A',
                        
                        // Data quality and validation info
                        data_validation: validation,
                        has_estimated_data: validation.estimatedFields.length > 0,
                        data_completeness: validation.completeness
                    };
                    
                    pipelines.push(pipeline);
                });

                return {
                    name: gifName,
                    content_type: originalInfo.content_type,
                    original: {
                        file_size_kb: originalInfo.size_kb,
                        frame_count: originalInfo.frame_count,
                        fps: originalInfo.fps,
                        duration: originalInfo.duration,
                        width: originalInfo.width,
                        height: originalInfo.height,
                        colors: originalInfo.colors,
                        entropy: originalInfo.entropy
                    },
                    pipelines: pipelines
                };
            }

            generateDisplayName(compressionData) {
                const tools = compressionData.tools_used || [];
                let name = tools.join(' + ').replace(/-/g, ' ');
                
                if (compressionData.applied_colors) {
                    name += ` (${compressionData.applied_colors} colors)`;
                }
                if (compressionData.applied_lossy) {
                    name += ` (${compressionData.applied_lossy}% lossy)`;
                }
                if (compressionData.applied_frame_ratio) {
                    name += ` (${(compressionData.applied_frame_ratio * 100).toFixed(0)}% frames)`;
                }
                
                return name || compressionData.pipeline;
            }

            calculateEfficiency(compressionData) {
                // Use enhanced composite quality if available, fall back to legacy
                // Enhanced quality already includes proper efficiency calculation
                if (compressionData.efficiency !== undefined) {
                    return compressionData.efficiency;
                }
                
                // Fallback calculation using enhanced composite quality if available
                const qualityScore = compressionData.enhanced_composite_quality || compressionData.composite_quality || 0;
                const compressionScore = Math.min(compressionData.compression_ratio / 10, 1);
                return (qualityScore * 0.6 + compressionScore * 0.4);
            }

            calculateGifAggregates(gif) {
                if (!gif.pipelines || gif.pipelines.length === 0) {
                    return { efficiency: 0, quality: 0, compression: 1, hasArtifacts: false };
                }
                
                // Calculate averages across all pipelines for this GIF
                const efficiencies = gif.pipelines.map(p => p.efficiency || 0);
                const qualities = gif.pipelines.map(p => p.enhanced_composite_quality || 0);
                const compressions = gif.pipelines.map(p => p.compression_ratio || 1);
                
                // Check for disposal artifacts (if ANY pipeline has artifacts, flag it)
                const hasArtifacts = gif.pipelines.some(p => {
                    const minScore = Math.min(p.disposal_artifacts_pre || 1, p.disposal_artifacts_post || 1);
                    const deltaThreshold = Math.abs(p.disposal_artifacts_delta || 0) > 0.1;
                    return minScore < 0.85 || deltaThreshold;
                });
                
                return {
                    efficiency: efficiencies.reduce((a, b) => a + b, 0) / efficiencies.length,
                    quality: qualities.reduce((a, b) => a + b, 0) / qualities.length,
                    compression: Math.max(...compressions), // Use best compression ratio
                    hasArtifacts: hasArtifacts
                };
            }

            populateGifSelect() {
                this.gifSelect.disabled = false;
                this.gifSelect.innerHTML = '<option value="">Select GIF...</option>';
                
                if (this.currentExperiment && this.currentExperiment.gifs) {
                    this.currentExperiment.gifs.forEach(gif => {
                        const option = document.createElement('option');
                        option.value = gif.name;
                        
                        // Calculate aggregate metrics for dropdown display
                        const aggregates = this.calculateGifAggregates(gif);
                        const efficiencyPercent = Math.round(aggregates.efficiency * 100);
                        const qualityScore = aggregates.quality.toFixed(2);
                        const compressionRatio = aggregates.compression.toFixed(1);
                        const artifactWarning = aggregates.hasArtifacts ? ' ‚ö†Ô∏è' : '';
                        
                        option.textContent = `${gif.name} (${gif.content_type}) - ${efficiencyPercent}% eff, ${qualityScore} qual, ${compressionRatio}x${artifactWarning}`;
                        this.gifSelect.appendChild(option);
                    });
                }
            }

            selectGif(gifName) {
                if (!gifName || !this.currentExperiment) {
                    this.pipelineFilters.classList.add('hidden');
                    this.clearComparison();
                    return;
                }

                this.currentGif = this.currentExperiment.gifs.find(g => g.name === gifName);
                if (this.currentGif) {
                    this.populatePipelineFilters();
                    this.pipelineFilters.classList.remove('hidden');
                }
            }

            populatePipelineFilters() {
                this.pipelineCheckboxes.innerHTML = '';
                this.selectedPipelines.clear();

                if (!this.currentGif || !this.currentGif.pipelines) return;

                this.currentGif.pipelines.forEach((pipeline, index) => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.className = 'pipeline-checkbox';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `pipeline-${pipeline.id}`;
                    checkbox.value = pipeline.id;
                    
                    // Auto-select the first pipeline
                    if (index === 0) {
                        checkbox.checked = true;
                        checkboxDiv.classList.add('selected');
                        this.selectedPipelines.add(pipeline.id);
                    }
                    
                    // Make entire thumbnail clickable
                    const togglePipeline = (e) => {
                        // Don't double-toggle if clicking directly on checkbox
                        if (e.target === checkbox) return;
                        
                        checkbox.checked = !checkbox.checked;
                        this.togglePipeline(pipeline.id, checkbox.checked);
                        checkboxDiv.classList.toggle('selected', checkbox.checked);
                    };
                    
                    checkboxDiv.addEventListener('click', togglePipeline);
                    
                    checkbox.addEventListener('change', (e) => {
                        this.togglePipeline(pipeline.id, e.target.checked);
                        checkboxDiv.classList.toggle('selected', e.target.checked);
                    });
                    
                    const info = document.createElement('div');
                    info.className = 'pipeline-info';
                    
                    const name = document.createElement('div');
                    name.className = 'pipeline-name';
                    name.textContent = pipeline.display_name;
                    
                    const stats = document.createElement('div');
                    stats.className = 'pipeline-stats';
                    stats.textContent = `${pipeline.file_size_kb.toFixed(1)} KB ‚Ä¢ ${pipeline.compression_ratio.toFixed(1)}x compression ‚Ä¢ ${(pipeline.efficiency * 100).toFixed(0)}% efficiency`;
                    
                    info.appendChild(name);
                    info.appendChild(stats);
                    
                    const efficiencyBar = document.createElement('div');
                    efficiencyBar.className = 'efficiency-bar';
                    
                    const efficiencyFill = document.createElement('div');
                    efficiencyFill.className = `efficiency-fill ${this.getEfficiencyClass(pipeline.efficiency)}`;
                    efficiencyFill.style.width = `${pipeline.efficiency * 100}%`;
                    
                    efficiencyBar.appendChild(efficiencyFill);
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(info);
                    checkboxDiv.appendChild(efficiencyBar);
                    
                    this.pipelineCheckboxes.appendChild(checkboxDiv);
                });
                
                // Update comparison to show auto-selected pipelines
                this.updateComparison();
            }

            togglePipeline(pipelineId, selected) {
                if (selected) {
                    this.selectedPipelines.add(pipelineId);
                } else {
                    this.selectedPipelines.delete(pipelineId);
                }
                this.updateComparison();
            }

            updateComparison() {
                this.clearComparison();
                
                if (!this.currentGif || !this.currentExperiment || this.selectedPipelines.size === 0) {
                    this.metricsPanel.classList.add('hidden');
                    return;
                }

                // Always show original first
                this.addGifCard({
                    src: `runs/${this.currentExperiment.experiment.id}/visual_outputs/${this.currentGif.name}/original.gif`,
                    title: 'Original',
                    metadata: {
                        size: `${this.currentGif.original.file_size_kb.toFixed(1)} KB`,
                        frames: `${this.currentGif.original.frame_count} frames`
                    },
                    isOriginal: true
                });

                // Add selected pipelines
                const selectedPipelineData = this.currentGif.pipelines.filter(p => 
                    this.selectedPipelines.has(p.id)
                );

                selectedPipelineData.forEach(pipeline => {
                    // Calculate FPS comparison for card display
                    const fpsValidation = this.validateFPS(pipeline.original_fps, pipeline.compressed_fps);
                    let fpsDisplay = '';
                    let fpsWarning = '';
                    
                    if (pipeline.original_fps !== 'N/A' && pipeline.compressed_fps !== 'N/A') {
                        const origFPS = parseFloat(pipeline.original_fps);
                        const compFPS = parseFloat(pipeline.compressed_fps);
                        
                        if (!isNaN(origFPS) && !isNaN(compFPS)) {
                            fpsDisplay = `FPS: ${origFPS.toFixed(1)} ‚Üí ${compFPS.toFixed(1)}`;
                            
                            if (fpsValidation.warning) {
                                const changeDesc = fpsValidation.percentChange > 0 ? 'faster' : 'slower';
                                fpsWarning = `‚ö†Ô∏è ${Math.abs(fpsValidation.percentChange).toFixed(0)}% ${changeDesc}`;
                            }
                        }
                    }
                    
                    const metadata = {
                        size: `${pipeline.file_size_kb.toFixed(1)} KB`,
                        frames: `${pipeline.frame_count} frames`,
                        compression: `${pipeline.compression_ratio.toFixed(1)}x smaller`,
                        quality: `Quality: ${pipeline.enhanced_composite_quality.toFixed(3)}`,
                        efficiency: `Efficiency: ${(pipeline.efficiency * 100).toFixed(0)}%`,
                        time: `${pipeline.render_time_ms}ms`
                    };
                    
                    // Add FPS info if available
                    if (fpsDisplay) {
                        metadata.fps = fpsDisplay;
                    }
                    if (fpsWarning) {
                        metadata.fpsWarning = fpsWarning;
                    }
                    
                    // Add duration if available
                    if (pipeline.compressed_duration && pipeline.compressed_duration !== 'N/A') {
                        const duration = parseFloat(pipeline.compressed_duration);
                        if (!isNaN(duration)) {
                            metadata.duration = `Duration: ${duration.toFixed(2)}s`;
                        }
                    }
                    
                    this.addGifCard({
                        src: `runs/${this.currentExperiment.experiment.id}/visual_outputs/${this.currentGif.name}/${pipeline.id}.gif`,
                        title: pipeline.display_name,
                        metadata: metadata,
                        efficiency: pipeline.efficiency,
                        fpsWarning: fpsValidation.warning
                    });
                });

                this.updateMetricsTable(selectedPipelineData);
            }

            addGifCard(options) {
                const card = document.createElement('div');
                card.className = 'gif-card';
                
                const container = document.createElement('div');
                container.className = 'gif-container';
                
                const img = document.createElement('img');
                img.src = options.src;
                img.alt = options.title;
                img.onerror = () => {
                    img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="100"><rect width="200" height="100" fill="%23f0f0f0"/><text x="100" y="50" text-anchor="middle" fill="%23999">Image not found</text></svg>';
                };
                
                const overlay = document.createElement('div');
                overlay.className = 'gif-overlay';
                
                const title = document.createElement('div');
                title.className = 'gif-title';
                
                const titleText = document.createElement('span');
                titleText.textContent = options.title;
                
                const fileLink = document.createElement('a');
                fileLink.className = 'file-link';
                fileLink.href = options.src;
                fileLink.target = '_blank';
                fileLink.textContent = 'View File';
                fileLink.title = `Open ${options.src} in new tab`;
                
                // Add copy path button
                const copyButton = document.createElement('button');
                copyButton.className = 'copy-path-button';
                copyButton.textContent = 'üìã Copy Path';
                copyButton.title = 'Copy absolute file path to clipboard';
                copyButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.copyAbsolutePath(options.src, copyButton);
                });
                
                title.appendChild(titleText);
                title.appendChild(fileLink);
                title.appendChild(copyButton);
                
                const metadata = document.createElement('div');
                metadata.className = 'metadata';
                
                Object.entries(options.metadata).forEach(([key, value]) => {
                    const span = document.createElement('span');
                    span.textContent = value;
                    metadata.appendChild(span);
                });
                
                overlay.appendChild(title);
                overlay.appendChild(metadata);
                container.appendChild(img);
                container.appendChild(overlay);
                card.appendChild(container);
                
                // Add efficiency styling for non-original cards
                if (!options.isOriginal && options.efficiency !== undefined) {
                    card.style.borderLeft = `4px solid ${this.getEfficiencyColor(options.efficiency)}`;
                }
                
                // Add FPS warning styling
                if (options.fpsWarning) {
                    card.style.borderTop = `3px solid #ff6b6b`;
                    card.classList.add('fps-warning-card');
                }
                
                this.comparisonGrid.appendChild(card);
            }

            updateMetricsTable(pipelines) {
                const tbody = this.metricsTable.querySelector('tbody');
                tbody.innerHTML = '';

                // Add original row
                const originalRow = document.createElement('tr');
                // Get original FPS from first pipeline or use default
                const originalFPS = pipelines.length > 0 ? pipelines[0].original_fps : 'N/A';
                const originalDuration = pipelines.length > 0 ? pipelines[0].original_duration : 'N/A';
                
                originalRow.innerHTML = `
                    <td><strong>Original</strong></td>
                    <td>${this.currentGif.original.file_size_kb.toFixed(1)} KB</td>
                    <td>${this.currentGif.original.frame_count}</td>
                    <td>1.0x</td>
                    <td>1.000</td>
                    <td>1.000</td>
                    <td>1.000</td>
                    <td>1.000</td>
                    <td>0.000</td>
                    <td>0.000</td>
                    <td>1.000</td>
                    <td>0.000</td>
                    <td>1.000</td>
                    <td>1.000</td>
                    <td>1.000</td>
                    <td>1.000</td>
                    <td>‚Äî</td>
                    <td>‚Äî</td>
                    <td>‚Äî</td>
                    <td>1.000</td>
                    <td>1.000</td>
                    <td>0.000</td>
                    <td class="fps-excellent">${originalFPS !== 'N/A' ? parseFloat(originalFPS).toFixed(1) : 'N/A'}</td>
                    <td>‚Äî</td>
                    <td>‚Äî</td>
                    <td>${originalDuration !== 'N/A' ? parseFloat(originalDuration).toFixed(2) : 'N/A'}</td>
                    <td>1.000</td>
                    <td>‚Äî</td>
                    <td>‚Äî</td>
                    <td>‚Äî</td>
                `;
                tbody.appendChild(originalRow);

                // Add pipeline rows
                pipelines.forEach((pipeline, index) => {
                    const row = document.createElement('tr');
                    
                    // Calculate FPS validation for this pipeline
                    const fpsValidation = this.validateFPS(pipeline.original_fps, pipeline.compressed_fps);
                    const fpsWarningClass = fpsValidation.warning ? 'fps-warning' : '';
                    
                    // Add data quality indicators
                    const dataQualityClass = this.getDataQualityClass(pipeline.data_validation);
                    const dataQualityTooltip = this.generateDataQualityTooltip(pipeline.data_validation);
                    
                    row.innerHTML = `
                        <td><strong>${pipeline.display_name}</strong></td>
                        <td>${pipeline.file_size_kb.toFixed(1)} KB</td>
                        <td>${pipeline.frame_count}</td>
                        <td>${pipeline.compression_ratio.toFixed(1)}x</td>
                        ${this.createMetricCell(pipeline.enhanced_composite_quality, 'Overall quality score combining all metrics')}
                        ${this.createMetricCell(pipeline.ssim, 'Structural Similarity Index (0-1, higher better)')}
                        ${this.createMetricCell(pipeline.ms_ssim, 'Multi-Scale SSIM (0-1, higher better)')}
                        ${this.createMetricCell(pipeline.psnr, 'Peak Signal-to-Noise Ratio (0-1, higher better)')}
                        ${this.createMetricCell(pipeline.mse, 'Mean Squared Error (0-1, lower better)', true)}
                        ${this.createMetricCell(pipeline.rmse, 'Root Mean Squared Error (0-1, lower better)', true)}
                        ${this.createMetricCell(pipeline.fsim, 'Feature Similarity Index (0-1, higher better)')}
                        ${this.createMetricCell(pipeline.gmsd, 'Gradient Magnitude Similarity Deviation (0-1, lower better)', true)}
                        ${this.createMetricCell(pipeline.chist, 'Color Histogram Correlation (0-1, higher better)')}
                        ${this.createMetricCell(pipeline.edge_similarity, 'Edge Similarity (0-1, higher better)')}
                        ${this.createMetricCell(pipeline.texture_similarity, 'Texture Similarity (0-1, higher better)')}
                        ${this.createMetricCell(pipeline.sharpness_similarity, 'Sharpness Similarity (0-1, higher better)')}
                        ${this.createMetricCell(pipeline.temporal_consistency_pre, 'Temporal consistency before compression')}
                        ${this.createMetricCell(pipeline.temporal_consistency_post, 'Temporal consistency after compression')}
                        ${this.createMetricCell(pipeline.temporal_consistency_delta, 'Change in temporal consistency')}
                        ${this.createMetricCell(pipeline.disposal_artifacts_pre, 'Disposal artifacts before compression (1.0 = perfect)')}
                        ${this.createMetricCell(pipeline.disposal_artifacts_post, 'Disposal artifacts after compression (1.0 = perfect)')}
                        ${this.createMetricCell(pipeline.disposal_artifacts_delta, 'Change in disposal artifacts')}
                        ${this.createFPSCell(pipeline.original_fps, 'Original animation frame rate')}
                        ${this.createFPSCell(pipeline.compressed_fps, 'Compressed animation frame rate', fpsValidation.cssClass, fpsWarningClass)}
                        ${this.createFPSDeltaCell(fpsValidation, 'Frame rate change percentage')}
                        ${this.createDurationCell(pipeline.compressed_duration, 'Total animation duration')}
                        ${this.createMetricCell(pipeline.timing_consistency, 'Frame timing consistency (1.0 = perfect)')}
                        <td style="color: ${this.getEfficiencyColor(pipeline.efficiency)}">
                            ${(pipeline.efficiency * 100).toFixed(0)}%
                        </td>
                        <td>${pipeline.render_time_ms}ms</td>
                        <td>
                            <button class="details-btn" data-pipeline-index="${index}">
                                üìä Frames
                            </button>
                        </td>
                    `;
                    tbody.appendChild(row);
                    
                    // Add event listener for frame breakdown button
                    const detailsBtn = row.querySelector('.details-btn');
                    if (detailsBtn) {
                        detailsBtn.addEventListener('click', () => {
                            this.toggleFrameBreakdown(index, pipeline, row);
                        });
                    }
                });

                this.metricsPanel.classList.remove('hidden');
            }

            // Toggle frame-by-frame breakdown for a pipeline
            toggleFrameBreakdown(pipelineIndex, pipeline, rowElement) {
                const existingBreakdown = rowElement.nextElementSibling;
                
                // If breakdown already exists, remove it
                if (existingBreakdown && existingBreakdown.classList.contains('frame-breakdown-row')) {
                    existingBreakdown.remove();
                    const btn = rowElement.querySelector('.details-btn');
                    btn.textContent = 'üìä Frames';
                    btn.classList.remove('expanded');
                    return;
                }
                
                // Create frame breakdown row
                const breakdownRow = document.createElement('tr');
                breakdownRow.className = 'frame-breakdown-row';
                
                const breakdownCell = document.createElement('td');
                breakdownCell.colSpan = 30; // Updated for new timing columns
                
                const breakdownContent = document.createElement('div');
                breakdownContent.className = 'frame-breakdown-content';
                
                // Generate frame breakdown HTML
                const frameCount = Math.min(pipeline.raw_metrics.ssim_raw.length, 10); // Limit to first 10 frames
                
                if (frameCount === 0 && (!pipeline.raw_metrics.frame_delays || pipeline.raw_metrics.frame_delays.length === 0)) {
                    breakdownContent.innerHTML = `
                        <h4>Frame-by-Frame Breakdown</h4>
                        <p>No frame-level metric data or timing data available for this pipeline.</p>
                    `;
                } else {
                    let frameHTML = `
                        <h4>Frame-by-Frame Breakdown</h4>
                    `;
                    
                    // Add timing analysis section if frame delays are available
                    const frameDelays = pipeline.raw_metrics.frame_delays || [];
                    if (frameDelays.length > 0) {
                        const avgDelay = frameDelays.reduce((a, b) => a + b) / frameDelays.length;
                        const minDelay = Math.min(...frameDelays);
                        const maxDelay = Math.max(...frameDelays);
                        const totalDuration = frameDelays.reduce((a, b) => a + b) / 1000;
                        const calculatedFPS = 1000 / avgDelay;
                        
                        frameHTML += `
                            <div style="background: #f8f9ff; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                                <h5>‚è±Ô∏è Timing Analysis</h5>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; font-size: 13px;">
                                    <div><strong>Average Delay:</strong> ${avgDelay.toFixed(1)}ms</div>
                                    <div><strong>Calculated FPS:</strong> ${calculatedFPS.toFixed(1)}</div>
                                    <div><strong>Total Duration:</strong> ${totalDuration.toFixed(2)}s</div>
                                    <div><strong>Min Delay:</strong> ${minDelay}ms</div>
                                    <div><strong>Max Delay:</strong> ${maxDelay}ms</div>
                                    <div><strong>Delay Range:</strong> ${maxDelay - minDelay}ms</div>
                                </div>
                                ${pipeline.timing_consistency !== 'N/A' ? 
                                    `<div style="margin-top: 10px;"><strong>Timing Consistency:</strong> ${(pipeline.timing_consistency * 100).toFixed(1)}% (${pipeline.timing_consistency >= 0.9 ? 'Excellent' : pipeline.timing_consistency >= 0.7 ? 'Good' : pipeline.timing_consistency >= 0.5 ? 'Fair' : 'Poor'})</div>` 
                                    : ''
                                }
                            </div>
                        `;
                    }
                    
                    // Add quality metrics breakdown if available
                    if (frameCount > 0) {
                        frameHTML += `
                            <h5>üìä Quality Metrics (First ${frameCount} frames)</h5>
                            <div class="frame-list">
                        `;
                        
                        for (let i = 0; i < frameCount; i++) {
                            const frameMetrics = {
                                ssim: pipeline.raw_metrics.ssim_raw[i] || 'N/A',
                                ms_ssim: pipeline.raw_metrics.ms_ssim_raw[i] || 'N/A',
                                psnr: pipeline.raw_metrics.psnr_raw[i] || 'N/A',
                                mse: pipeline.raw_metrics.mse_raw[i] || 'N/A',
                                fsim: pipeline.raw_metrics.fsim_raw[i] || 'N/A',
                                edge: pipeline.raw_metrics.edge_raw[i] || 'N/A',
                                texture: pipeline.raw_metrics.texture_raw[i] || 'N/A',
                                sharpness: pipeline.raw_metrics.sharpness_raw[i] || 'N/A'
                            };
                            
                            // Add frame delay if available
                            const frameDelay = frameDelays[i] ? `${frameDelays[i]}ms` : 'N/A';
                            const frameRate = frameDelays[i] ? `${(1000/frameDelays[i]).toFixed(1)} FPS` : 'N/A';
                            
                            frameHTML += `
                                <div class="frame-item">
                                    <h5>Frame ${i + 1}</h5>
                                    ${frameDelays[i] ? `<div style="background: #e8f4fd; padding: 5px; border-radius: 4px; margin-bottom: 8px; font-size: 11px;">
                                        <strong>Timing:</strong> ${frameDelay} (${frameRate})
                                    </div>` : ''}
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 12px;">
                                        <div>SSIM: ${this.formatFrameMetric(frameMetrics.ssim)}</div>
                                        <div>MS-SSIM: ${this.formatFrameMetric(frameMetrics.ms_ssim)}</div>
                                        <div>PSNR: ${this.formatFrameMetric(frameMetrics.psnr)}</div>
                                        <div>MSE: ${this.formatFrameMetric(frameMetrics.mse)}</div>
                                        <div>FSIM: ${this.formatFrameMetric(frameMetrics.fsim)}</div>
                                        <div>Edge: ${this.formatFrameMetric(frameMetrics.edge)}</div>
                                        <div>Texture: ${this.formatFrameMetric(frameMetrics.texture)}</div>
                                        <div>Sharpness: ${this.formatFrameMetric(frameMetrics.sharpness)}</div>
                                    </div>
                                </div>
                            `;
                        }
                        
                        frameHTML += '</div>';
                    }
                    
                    breakdownContent.innerHTML = frameHTML;
                }
                
                breakdownCell.appendChild(breakdownContent);
                breakdownRow.appendChild(breakdownCell);
                
                // Insert breakdown row after current row
                rowElement.parentNode.insertBefore(breakdownRow, rowElement.nextSibling);
                
                // Update button state
                const btn = rowElement.querySelector('.details-btn');
                btn.textContent = '‚ùå Hide';
                btn.classList.add('expanded');
            }

            // Helper function to format frame metrics
            formatFrameMetric(value) {
                if (value === 'N/A' || value === null || value === undefined) {
                    return 'N/A';
                }
                const numValue = parseFloat(value);
                if (isNaN(numValue)) {
                    return 'N/A';
                }
                return numValue.toFixed(3);
            }

            // Calculate FPS from frame delays or other timing data
            calculateFPSFromData(data) {
                // Try different data sources for FPS calculation
                if (data.frame_delays && data.frame_delays.length > 0) {
                    const avgDelay = data.frame_delays.reduce((a, b) => a + b) / data.frame_delays.length;
                    return avgDelay > 0 ? 1000 / avgDelay : null;
                }
                
                // Fallback: try to extract from other timing info
                if (data.orig_fps) return data.orig_fps;
                if (data.fps) return data.fps;
                
                // Calculate from frame count and duration if available
                if (data.frame_count && data.duration) {
                    return data.frame_count / data.duration;
                }
                
                return null;
            }

            // Calculate total animation duration
            calculateDuration(data) {
                // Try frame delays first
                if (data.frame_delays && data.frame_delays.length > 0) {
                    const totalDelayMs = data.frame_delays.reduce((a, b) => a + b);
                    return totalDelayMs / 1000; // Convert to seconds
                }
                
                // Fallback calculations
                if (data.duration) return data.duration;
                if (data.frame_count && data.orig_fps) return data.frame_count / data.orig_fps;
                if (data.frame_count && data.fps) return data.frame_count / data.fps;
                
                return null;
            }

            // Calculate timing consistency score (lower standard deviation = more consistent)
            calculateTimingConsistency(frameDelays) {
                if (!frameDelays || frameDelays.length <= 1) return 'N/A';
                
                const mean = frameDelays.reduce((a, b) => a + b) / frameDelays.length;
                const variance = frameDelays.reduce((sum, delay) => sum + Math.pow(delay - mean, 2), 0) / frameDelays.length;
                const stdDev = Math.sqrt(variance);
                
                // Convert to consistency score (1.0 = perfect consistency, lower = less consistent)
                const consistencyScore = Math.max(0, 1 - (stdDev / mean));
                return consistencyScore;
            }

            // Validate FPS with configurable tolerance
            validateFPS(originalFPS, compressedFPS, tolerance = 0.1) {
                if (originalFPS === 'N/A' || compressedFPS === 'N/A' || !originalFPS || !compressedFPS) {
                    return { valid: null, reason: 'Missing FPS data', percentChange: 0, cssClass: '' };
                }
                
                const origFPS = parseFloat(originalFPS);
                const compFPS = parseFloat(compressedFPS);
                
                if (isNaN(origFPS) || isNaN(compFPS)) {
                    return { valid: null, reason: 'Invalid FPS data', percentChange: 0, cssClass: '' };
                }
                
                const percentChange = ((compFPS - origFPS) / origFPS) * 100;
                const deviation = Math.abs(percentChange) / 100;
                
                let valid = deviation <= tolerance;
                let cssClass = '';
                
                if (deviation <= 0.05) cssClass = 'fps-excellent'; // ¬±5%
                else if (deviation <= 0.1) cssClass = 'fps-good'; // ¬±10%
                else if (deviation <= 0.2) cssClass = 'fps-fair'; // ¬±20%
                else cssClass = 'fps-poor'; // >20%
                
                return { 
                    valid: valid, 
                    deviation: deviation,
                    percentChange: percentChange,
                    cssClass: cssClass,
                    warning: deviation > tolerance
                };
            }

            // Helper functions for FPS-specific cells
            createFPSCell(fps, tooltip, cssClass = '', warningClass = '') {
                if (fps === 'N/A' || fps === null || fps === undefined) {
                    return '<td class="metric-cell" title="FPS data not available">N/A</td>';
                }
                
                const numFPS = parseFloat(fps);
                if (isNaN(numFPS)) {
                    return '<td class="metric-cell" title="Invalid FPS data">‚Äî</td>';
                }
                
                const classes = ['metric-cell', cssClass, warningClass].filter(c => c).join(' ');
                return `<td class="${classes}" title="${tooltip}">${numFPS.toFixed(1)}</td>`;
            }
            
            createFPSDeltaCell(fpsValidation, tooltip) {
                if (fpsValidation.valid === null) {
                    return '<td class="metric-cell" title="Cannot calculate FPS change">‚Äî</td>';
                }
                
                const percentChange = fpsValidation.percentChange;
                const sign = percentChange > 0 ? '+' : '';
                const warningClass = fpsValidation.warning ? 'fps-warning' : '';
                const classes = ['metric-cell', fpsValidation.cssClass, warningClass].filter(c => c).join(' ');
                
                return `<td class="${classes}" title="${tooltip}">${sign}${percentChange.toFixed(1)}%</td>`;
            }
            
            createDurationCell(duration, tooltip) {
                if (duration === 'N/A' || duration === null || duration === undefined) {
                    return '<td class="metric-cell" title="Duration not available">N/A</td>';
                }
                
                const numDuration = parseFloat(duration);
                if (isNaN(numDuration)) {
                    return '<td class="metric-cell" title="Invalid duration data">‚Äî</td>';
                }
                
                return `<td class="metric-cell" title="${tooltip}">${numDuration.toFixed(2)}s</td>`;
            }

            // Data quality and validation helper functions
            getDataQualityClass(validation) {
                if (!validation) return '';
                
                if (validation.errors.length > 0) return 'data-error';
                if (validation.warnings.length > 0) return 'data-warning';
                if (validation.estimatedFields.length > 0) return 'data-estimated';
                if (validation.completeness < 0.8) return 'data-incomplete';
                
                return 'data-good';
            }
            
            generateDataQualityTooltip(validation) {
                if (!validation) return 'Data validation unavailable';
                
                let tooltip = `Data Completeness: ${(validation.completeness * 100).toFixed(0)}%`;
                
                if (validation.errors.length > 0) {
                    tooltip += `\nErrors: ${validation.errors.join(', ')}`;
                }
                
                if (validation.warnings.length > 0) {
                    tooltip += `\nWarnings: ${validation.warnings.join(', ')}`;
                }
                
                if (validation.estimatedFields.length > 0) {
                    tooltip += `\nEstimated: ${validation.estimatedFields.join(', ')}`;
                }
                
                return tooltip;
            }
            
            // Enhanced metric cell creation with data quality indicators
            createEnhancedMetricCell(value, tooltip, invertScale = false, dataQuality = null) {
                const basicCell = this.createMetricCell(value, tooltip, invertScale);
                
                if (!dataQuality || value === 'N/A') {
                    return basicCell;
                }
                
                // Add data quality indicator to the cell
                const qualityClass = this.getDataQualityClass(dataQuality);
                const qualityTooltip = this.generateDataQualityTooltip(dataQuality);
                
                if (qualityClass && qualityClass !== 'data-good') {
                    return basicCell.replace('class="metric-cell', `class="metric-cell ${qualityClass}`)
                                   .replace('title="', `title="${qualityTooltip}\n\n`);
                }
                
                return basicCell;
            }

            // Helper function to create metric cells with color coding and tooltips
            createMetricCell(value, tooltip, invertScale = false) {
                if (value === 'N/A' || value === null || value === undefined) {
                    return '<td class="metric-cell" title="Metric not available">N/A</td>';
                }

                const numValue = parseFloat(value);
                if (isNaN(numValue)) {
                    return '<td class="metric-cell" title="Invalid metric value">‚Äî</td>';
                }

                // Determine color class based on value (invert for metrics where lower is better)
                let colorClass;
                const thresholds = invertScale 
                    ? { excellent: 0.2, good: 0.4, fair: 0.6 } // Lower is better (MSE, RMSE, GMSD)
                    : { excellent: 0.8, good: 0.6, fair: 0.4 }; // Higher is better (most metrics)

                if (invertScale) {
                    if (numValue <= thresholds.excellent) colorClass = 'metric-excellent';
                    else if (numValue <= thresholds.good) colorClass = 'metric-good';
                    else if (numValue <= thresholds.fair) colorClass = 'metric-fair';
                    else colorClass = 'metric-poor';
                } else {
                    if (numValue >= thresholds.excellent) colorClass = 'metric-excellent';
                    else if (numValue >= thresholds.good) colorClass = 'metric-good';
                    else if (numValue >= thresholds.fair) colorClass = 'metric-fair';
                    else colorClass = 'metric-poor';
                }

                return `<td class="metric-cell ${colorClass}" title="${tooltip}">${numValue.toFixed(3)}</td>`;
            }

            clearComparison() {
                this.comparisonGrid.innerHTML = '';
                this.metricsPanel.classList.add('hidden');
            }

            getEfficiencyClass(efficiency) {
                if (efficiency >= 0.8) return 'efficiency-excellent';
                if (efficiency >= 0.6) return 'efficiency-good'; 
                if (efficiency >= 0.4) return 'efficiency-fair';
                return 'efficiency-poor';
            }

            getEfficiencyColor(efficiency) {
                if (efficiency >= 0.8) return '#4CAF50';
                if (efficiency >= 0.6) return '#8BC34A';
                if (efficiency >= 0.4) return '#FFC107';
                return '#FF5722';
            }

            async discoverExperimentsFromFilesystem() {
                console.log('üîç Starting experiment discovery from filesystem...');
                const experiments = [];
                
                // Check only current runs directory
                const searchLocations = [
                    { path: 'runs/', label: 'current runs', prefix: 'runs' }
                ];
                
                for (const location of searchLocations) {
                    console.log(`üìÇ Fetching ${location.label} from ${location.path}...`);
                    try {
                        const response = await fetch(location.path);
                        const html = await response.text();
                        console.log(`üìã Got ${location.label} directory listing`);
                        
                        // Parse directory names from HTML listing
                        const dirRegex = /href="([^"]+\/)"/g;
                        const directories = [];
                        let match;
                        
                        while ((match = dirRegex.exec(html)) !== null) {
                            const dirName = match[1].replace('/', ''); // Remove trailing slash
                            // Skip system directories
                            if (!dirName.startsWith('.') && dirName !== 'latest' && !dirName.includes('cache') && !dirName.includes('pipeline_results_cache')) {
                                directories.push(dirName);
                                console.log(`   üìÅ Found ${location.label} directory: ${dirName}`);
                            }
                        }
                        
                        console.log(`üìä Found ${directories.length} potential ${location.label} directories`);
                        
                        // Check each directory to see if it's a valid experiment
                        for (const expId of directories) {
                            console.log(`üîç Checking ${location.label}: ${expId}`);
                            const experiment = await this.checkExperimentExists(expId, location.prefix);
                            if (experiment) {
                                experiments.push(experiment);
                                console.log(`‚úÖ Valid ${location.label}: ${expId}`);
                            } else {
                                console.log(`‚ùå Invalid ${location.label}: ${expId}`);
                            }
                        }
                        
                    } catch (error) {
                        console.log(`‚ùå Failed to fetch ${location.label}: ${error.message}`);
                    }
                }
                
                // Fallback to testing known experiments if none found
                if (experiments.length === 0) {
                    console.log('üìÇ No experiments found, trying fallback to known experiments...');
                    const knownExperiments = [
                        '021-quick-test-18-08-25',
                        '001-gifsicle-frame-validation-16-08-25',
                        '061-quick-test-18-08-25'
                    ];
                    
                    for (const expId of knownExperiments) {
                        const experiment = await this.checkExperimentExists(expId, 'runs');
                        if (experiment) {
                            experiments.push(experiment);
                            console.log('‚úÖ Found fallback experiment:', experiment.id);
                            break; // Just need one to get started
                        }
                    }
                }
                
                console.log(`üìä Discovery complete. Found ${experiments.length} experiments:`);
                experiments.forEach(exp => {
                    console.log(`   - ${exp.id}: "${exp.name}" (${exp.gifs_count} GIFs)`);
                });
                
                // Sort by date (newest first) if we have date info
                experiments.sort((a, b) => new Date(b.date) - new Date(a.date));
                
                return experiments;
            }
            
            async tryExperimentPatterns(baseName, experiments) {
                // Try different date patterns with the base name
                const today = new Date();
                const datePatterns = [
                    // Recent dates in DD-MM-YY format
                    '16-08-25', '15-08-25', '14-08-25', '13-08-25', '12-08-25', '11-08-25',
                    // Today and recent days in DD-MM-YY
                    today.toLocaleDateString('en-GB', {day: '2-digit', month: '2-digit', year: '2-digit'}).replace(/\//g, '-'),
                    // YYYY-MM-DD format
                    '2025-08-16', '2025-08-15', '2025-08-14', '2025-08-13', '2025-08-12', '2025-08-11'
                ];
                
                for (const date of datePatterns) {
                    const expId = `${baseName}-${date}`;
                    const experiment = await this.checkExperimentExists(expId, 'runs');
                    if (experiment && !experiments.find(e => e.id === experiment.id)) {
                        experiments.push(experiment);
                        console.log(`‚úÖ Discovered: ${expId}`);
                    }
                }
                
                // Also try without date suffix
                const experiment = await this.checkExperimentExists(baseName, 'runs');
                if (experiment && !experiments.find(e => e.id === experiment.id)) {
                    experiments.push(experiment);
                    console.log(`‚úÖ Discovered: ${baseName}`);
                }
            }
            
            async checkExperimentExists(expId, locationPrefix = 'runs') {
                try {
                    console.log(`üîç Checking experiment: ${expId} in ${locationPrefix}/`);
                    
                    // Check if experiment has required structure
                    const metadataPath = `${locationPrefix}/${expId}/run_metadata.json`;
                    const visualOutputsPath = `${locationPrefix}/${expId}/visual_outputs`;
                    
                    console.log(`   üìÑ Checking metadata: ${metadataPath}`);
                    const hasMetadata = await this.checkFileExists(metadataPath);
                    console.log(`   üìÑ Metadata exists: ${hasMetadata}`);
                    
                    console.log(`   üìÅ Checking visual outputs: ${visualOutputsPath}`);
                    const hasVisualOutputs = await this.checkDirectoryExists(visualOutputsPath);
                    console.log(`   üìÅ Visual outputs exists: ${hasVisualOutputs}`);
                    
                    // Require metadata, but allow experiments without visual outputs (with fallback)
                    if (!hasMetadata) {
                        console.log(`   ‚ùå ${expId} missing required metadata file`);
                        return null;
                    }
                    
                    if (!hasVisualOutputs) {
                        console.log(`   ‚ö†Ô∏è ${expId} missing visual outputs - will use fallback display`);
                    }
                    
                    console.log(`   ‚úÖ ${expId} has required structure`);
                    
                    // Load metadata
                    let metadata = {};
                    try {
                        const metadataResponse = await fetch(`${locationPrefix}/${expId}/run_metadata.json`);
                        if (metadataResponse.ok) {
                            metadata = await metadataResponse.json();
                        }
                    } catch (e) {
                        console.warn(`Could not load metadata for ${expId}`);
                    }
                    
                    // Count GIFs
                    const gifCount = await this.countGifsInVisualOutputs(`${locationPrefix}/${expId}/visual_outputs`);
                    
                    // Use actual metadata timestamp if available, otherwise extract from ID
                    let date = new Date().toISOString();
                    if (metadata.jobs_updated_at) {
                        date = metadata.jobs_updated_at;
                    } else if (metadata.timestamp) {
                        date = metadata.timestamp;
                    } else {
                        // Fallback: extract date from experiment ID
                        const dateMatch = expId.match(/-(\d{2}-\d{2}-\d{2})$/);
                        if (dateMatch) {
                            const [, shortDate] = dateMatch;
                            const [day, month, year] = shortDate.split('-');
                            date = new Date(`20${year}-${month}-${day}`).toISOString();
                        }
                    }
                    
                    return {
                        id: expId,
                        name: metadata.name || this.generateExperimentName(expId),
                        preset: metadata.preset || 'custom',
                        description: metadata.description || `Experiment: ${expId}`,
                        date: date,
                        gifs_count: gifCount,
                        pipelines_count: metadata.pipeline_count || 'unknown',
                        path: `${locationPrefix}/${expId}`,
                        has_visual_outputs: hasVisualOutputs
                    };
                    
                } catch (error) {
                    return null;
                }
            }
            
            generateExperimentName(expId) {
                // Generate human-readable name from experiment ID, keeping ID for uniqueness
                const idMatch = expId.match(/^([0-9]{3})-(.+)-([0-9]{2}-[0-9]{2}-[0-9]{2})$/);
                if (idMatch) {
                    const [, experimentNum, experimentName, dateStr] = idMatch;
                    const readableName = experimentName
                        .replace(/-/g, ' ') // Replace dashes with spaces
                        .replace(/\b\w/g, l => l.toUpperCase()); // Capitalize words
                    return `${readableName} (#${experimentNum})`;
                }
                
                // Fallback for non-standard naming
                return expId.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            
            async countGifsInVisualOutputs(visualOutputsPath) {
                const knownGifNames = [
                    'animation_heavy', 'complex_gradient', 'data_visualization', 'extended_animation',
                    'few_colors', 'geometric_patterns', 'gradient_large', 'gradient_medium', 
                    'gradient_small', 'gradient_xlarge', 'high_contrast', 'high_frequency_detail',
                    'long_animation', 'many_colors', 'minimal_frames', 'mixed_content',
                    'noise_large', 'noise_small', 'photographic_noise', 'single_pixel_anim',
                    'smooth_gradient', 'solid_blocks', 'static_minimal_change', 'texture_complex', 
                    'transitions'
                ];
                
                let count = 0;
                for (const gifName of knownGifNames) {
                    try {
                        const response = await fetch(`${visualOutputsPath}/${gifName}/metrics.json`, { method: 'HEAD' });
                        if (response.ok) {
                            count++;
                        }
                    } catch {
                        continue;
                    }
                }
                
                return count;
            }
            
            async checkFileExists(filePath) {
                try {
                    console.log(`      üåê Fetching: ${filePath}`);
                    const response = await fetch(filePath, { method: 'HEAD' });
                    console.log(`      üì° Response: ${response.status} ${response.statusText}`);
                    return response.ok;
                } catch (error) {
                    console.log(`      ‚ùå Fetch error: ${error.message}`);
                    return false;
                }
            }
            
            async checkDirectoryExists(dirPath) {
                console.log(`      üìÅ Testing directory: ${dirPath}`);
                
                // For visual_outputs directory, check if it has subdirectories with metrics.json
                if (dirPath.includes('visual_outputs')) {
                    console.log(`        üîç Checking for subdirectories with metrics.json...`);
                    
                    // Try some common GIF names that might exist as subdirectories
                    const testSubdirs = [
                        'animation_heavy', 'smooth_gradient', 'complex_gradient', 
                        'many_colors', 'few_colors', 'high_contrast', 'noise_large'
                    ];
                    
                    for (const subdir of testSubdirs) {
                        try {
                            const testPath = `${dirPath}/${subdir}/metrics.json`;
                            console.log(`        üîç Testing: ${testPath}`);
                            const response = await fetch(testPath, { method: 'HEAD' });
                            console.log(`        üì° Response: ${response.status} ${response.statusText}`);
                            if (response.ok) {
                                console.log(`        ‚úÖ Visual outputs directory confirmed via: ${subdir}/metrics.json`);
                                return true;
                            }
                        } catch (error) {
                            console.log(`        ‚ùå Error testing ${subdir}: ${error.message}`);
                            continue;
                        }
                    }
                    
                    console.log(`      ‚ùå No valid subdirectories found in visual_outputs`);
                    return false;
                }
                
                // For other directories, use original logic
                const testFiles = ['metrics.json', 'run_metadata.json'];
                for (const file of testFiles) {
                    try {
                        const testPath = `${dirPath}/${file}`;
                        console.log(`        üîç Testing: ${testPath}`);
                        const response = await fetch(testPath, { method: 'HEAD' });
                        console.log(`        üì° Response: ${response.status} ${response.statusText}`);
                        if (response.ok) {
                            console.log(`        ‚úÖ Directory confirmed via: ${file}`);
                            return true;
                        }
                    } catch (error) {
                        console.log(`        ‚ùå Error testing ${file}: ${error.message}`);
                        continue;
                    }
                }
                console.log(`      ‚ùå Directory not accessible: ${dirPath}`);
                return false;
            }
            

            formatDate(dateString) {
                const date = new Date(dateString);
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                // Check if it's today or yesterday for friendlier display
                if (date.toDateString() === today.toDateString()) {
                    return `Today ${date.toLocaleTimeString('en-AU', {hour: '2-digit', minute:'2-digit'})}`;
                } else if (date.toDateString() === yesterday.toDateString()) {
                    return `Yesterday ${date.toLocaleTimeString('en-AU', {hour: '2-digit', minute:'2-digit'})}`;
                } else {
                    return date.toLocaleDateString('en-AU', {day: '2-digit', month: '2-digit', year: '2-digit'}) + ' ' + 
                           date.toLocaleTimeString('en-AU', {hour: '2-digit', minute:'2-digit'});
                }
            }

            copyAbsolutePath(relativePath, buttonElement) {
                // Convert relative path to absolute path
                const basePath = '/Users/lachlants/repos/animately/giflab/results';
                const absolutePath = `${basePath}/${relativePath}`;
                
                // Copy to clipboard
                navigator.clipboard.writeText(absolutePath).then(() => {
                    // Visual feedback
                    const originalText = buttonElement.textContent;
                    buttonElement.textContent = '‚úÖ Copied!';
                    buttonElement.classList.add('copied');
                    
                    setTimeout(() => {
                        buttonElement.textContent = originalText;
                        buttonElement.classList.remove('copied');
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy path:', err);
                    // Fallback: show path in alert
                    alert(`Copy this path:\\n${absolutePath}`);
                });
            }

            showError(message) {
                const error = document.createElement('div');
                error.className = 'error';
                error.textContent = message;
                
                // Insert after header
                const header = document.querySelector('.header');
                header.insertAdjacentElement('afterend', error);
                
                setTimeout(() => error.remove(), 5000);
            }
        }


        // Initialize the comparison tool when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const app = new GifLabComparison();
            
            // Make app available globally for debugging
            window.app = app;
            
            // Add global debug functions for manual testing
            window.debugDiscovery = async function() {
                console.log('üîß Manual debug: Starting experiment discovery...');
                try {
                    const experiments = await app.discoverExperimentsFromFilesystem();
                    console.log('üîß Manual debug: Discovery complete');
                    console.log('üîß Experiments found:', experiments);
                    return experiments;
                } catch (error) {
                    console.log('üîß Manual debug: Error during discovery:', error);
                    return error;
                }
            };
            
            window.debugCheckExperiment = async function(expId, locationPrefix = 'runs') {
                console.log(`üîß Manual debug: Checking experiment ${expId} in ${locationPrefix}/`);
                try {
                    const result = await app.checkExperimentExists(expId, locationPrefix);
                    console.log('üîß Manual debug: Check complete');
                    console.log('üîß Result:', result);
                    return result;
                } catch (error) {
                    console.log('üîß Manual debug: Error checking experiment:', error);
                    return error;
                }
            };
            
            window.debugFileExists = async function(filePath) {
                console.log(`üîß Manual debug: Checking file ${filePath}`);
                try {
                    const result = await app.checkFileExists(filePath);
                    console.log('üîß Manual debug: File check complete');
                    console.log('üîß Result:', result);
                    return result;
                } catch (error) {
                    console.log('üîß Manual debug: Error checking file:', error);
                    return error;
                }
            };
            
            // Test function to verify the fix
            window.testDiscoveryFix = async function() {
                console.log('üß™ Testing discovery fix...');
                
                // Test the known experiment
                const result = await app.checkExperimentExists('001-gifsicle-frame-validation-16-08-25', 'runs');
                console.log(`Test result: ${result ? '‚úÖ SUCCESS' : '‚ùå FAILED'}`);
                
                if (result) {
                    console.log('üéâ Fix is working! The experiment should now be discoverable.');
                } else {
                    console.log('‚ùå Fix did not resolve the issue. Check console for details.');
                }
                
                return result;
            };
            
            console.log('üîß Debug functions available:');
            console.log('   - debugDiscovery() - Run full discovery process');
            console.log('   - debugCheckExperiment("experiment-id") - Test specific experiment');
            console.log('   - debugFileExists("path/to/file") - Test file existence');
            console.log('   - testDiscoveryFix() - Test the directory validation fix');
        });
    </script>
</body>
</html>